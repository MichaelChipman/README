# Michael Chipman | Aspiring AI Engineer



### AAS Degree Candidate at Maestro College



I am a foundational learner committed to developing robust AI engineering and automation skills. My program is delivered through innovative 1-on-1 AI-driven instruction, which informs my practical, tool-leveraged approach to engineering. Currently, I am building my core software development expertise, starting with **Python (Py 101)**.



This repository serves as my living portfolio, documenting my journey, showcasing class assignments, and tracking personal coding experiments as I progress through the program.



## üåü My Drive & Interests



My focus is on using technology to **automate tasks and solve real-world problems** efficiently. I believe in exploring AI's power and building tools that help teams move forward safely.



This drive for **methodical creation** extends to my hobbies, which include **woodworking** and video games focused on automation, balanced by the **creativity** of baking and cooking.



## üß† AI-Assisted Learning & Methodology

As an aspiring AI engineer, I leverage advanced generative models to enhance my learning and maintain high documentation standards. I use an AI learning assistant to generate clear, structured docstrings, comprehensive code comments, and professional Git commit messages (following Conventional Commits standards).

This approach accelerates my learning by ensuring all code is well-documented and allows me to focus my energy on the core engineering and problem-solving aspects of the projects.


## üöÄ Learning Modules & Projects



### 1. Foundational Python Scripts (Py 101)



These are hands-on assignments focusing on essential programming concepts to build a strong engineering base.



| File | Status | Description | 

 | ----- | ----- | ----- | 

| [`py_101/scoreboard.py`](py_101/scoreboard.py) | Complete (Lesson 1) | Demonstrates core Python syntax, variable management, user input/output handling, and effective in-line commenting. | 

| [`py_101/badge_generator.py`](py_101/badge_generator.py) | Complete (Lesson 2) | Focuses on **Error Handling (TypeError/NameError)**, **Type Checking**, variable type conversion (`int()`), and advanced string creation for output. |

| [`py_101/badge_expressions.py`](py_101/badge_expressions.py) | Complete (Lesson 3) | Focuses on **Arithmetic Expressions**, **Operator Precedence**, `f-string` formatting with math (`:.2f`), and type handling (int, float) for accurate calculations. ([Title: [Py 101 - Lesson 3] Price Board Project: Mastering Arithmetic & Operator Precedence**](https://www.reddit.com/r/maestro/comments/1oo1a3s/title_py_101_lesson_3_price_board_project/)) |

| [`py_101/badge_update_print.py`](py_101/badge_update_print.py) | Complete (Lesson 4) | Focuses on **Compound Assignment** (`+=`, `-=`), variable reassignment, **comma-separated `print()`**, and the use of the **`round()`** function to correct **floating-point imprecision** due to the base-2 system. |

| [`py_101/balance_board.py`](py_101/balance_board.py) | Complete (L4 Stretch) | A dedicated stretch challenge project demonstrating **tuple creation** via comma assignment, the resulting `len()` constraint, and the required **string concatenation workaround** for calculating dynamic border sizes. |

| [`py_101/modeling_real_world_calculations.py`](py_101/modeling_real_world_calculations.py) | Complete (Lesson 5) | Focuses on translating word problems, comparing expression clarity, and a deep dive into **Type Errors** and **String/Tuple data type constraints** when using concatenation (`+`) versus explicit `str()` casting. |

| [`py_101/division_ops.py`](py_101/division_ops.py) | Complete (Lesson 6) | Focuses on the three division operators: **True Division (`/`)**, **Floor Division (`//`)**, and the **Modulo Operator (`%`)** for finding quotients and remainders in practical, real-world applications (e.g., time and boxes). |

| [`py_101/modulo_practice.py`](py_101/modulo_practice.py) | Complete (Lesson 7) | Focuses on advanced applications of the **Modulo Operator (`%`)** for determining **parity** (even/odd), calculating **cycle repetition**, and finding a specific **position** within a repeating sequence (e.g., scheduling). |

| [`py_101/rounding_and_money.py`](py_101/rounding_and_money.py) | Complete (Lesson 8) | Demonstrates **currency formatting** by distinguishing between **value rounding** (`round()`) and **output formatting** (`:.2f`), explicitly addressing floating-point imprecision and reusing the Modulo Operator for scheduling. |

| [`py_101/user_input_demo.py`](py_101/user_input_demo.py) | Complete (Lesson 9) | Focuses on **user input (`input()`)** and **explicit type casting** (`int()`, `float()`), demonstrating how to handle raw string input and convert it into numerical data required for calculations like averaging test scores. |

| [`py_101/functions_i.py`](py_101/functions_i.py) | Complete (Lesson 10) | Introduces **functional programming**, demonstrating the core concepts of **definition (`def`)**, **calling**, and using **parameters (arguments)** to create reusable, organized, and self-documenting code with `docstrings`. |

| [`py_101/functions_return_practice.py`](py_101/functions_return_practice.py) | Complete (Lesson 11) | Focuses on the **`return` statement**, demonstrating how functions pass data back to the calling scope. It explicitly contrasts function output (return value) with **side effects** (debugging `print` statements). |

| [`py_101/functions_return_vs_print.py`](py_101/functions_return_vs_print.py) | Complete (Lesson 12) | Compares the function of `print()` vs. `return`, demonstrates dynamic formatting, and illustrates the use of the early return statement. |

| [`py_101/scope_demo.py`](py_101/scope_demo.py) | Complete (Lesson 13) | Demonstrates global vs. local variable scope, variable shadowing, and how the return statement is necessary to update global state. |

| [`py_101/python_errors.py`](py_101/python_errors.py) | Complete (Lesson 14) | Demonstrates how to read and interpret Python tracebacks and identifies common errors like NameError, TypeError, and UnboundLocalError. |

| [`py_101/debugging_intro.py`](py_101/debugging_intro.py) | Complete (Lesson 15) | Introduces fundamental debugging practices, including using `print()` probes to trace variable values and identifying bugs in basic arithmetic and type-mixing operations. |

| [`py_101/mini_receipt_calculator.py`](py_101/mini_receipt_calculator.py) | Complete (Wk 1 Review) | A capstone project demonstrating **user input**, **explicit type casting**, **function definition**, and advanced **f-string currency formatting** to generate a real-store receipt layout. |

| [`py_101/decisions_vs_repetitions.py`](py_101/decisions_vs_repetitions.py) | Complete (Lesson 16) | Introduces the foundational concepts of **decision structures** (`#S`) and **repetition structures** (`#R`) by differentiating between conditional actions and iterative tasks. |

| [`py_101/if_else_mental.py`](py_101/if_else_mental.py) | Complete (Lesson 17) | Demonstrates core `if`/`else` syntax, the importance of **indentation** and **comparison operators**, including checking for parity using the **Modulo Operator (`%`)**. |

| [`py_101/logical_operations_demo.py`](py_101/logical_operations_demo.py) | Complete (Lesson 18) | Demonstrates **logical operators (`and`, `or`, `not`)**, how **truth tables** function, and the efficiency concept of **short-circuit evaluation** in conditional statements. |

| [`py_101/identity_vs_equality.py`](py_101/identity_vs_equality.py) | Complete (Lesson 19) | Explores the difference between **Value Equality (`==`)** and **Object Identity (`is`)**, including concepts like **Boolean representation**, **integer caching**, and **floating-point imprecision**. |

| [`py_101/string_membership_and_conditionals.py`](py_101/string_membership_and_conditionals.py) | New (Lesson 20) | Demonstrates the usage of the **`in`** and **`not in`** string membership operators and fundamental **`if/elif/else`** conditional control flow, including case sensitivity. |

| [`py_101/elif_refactoring.py`](py_101/elif_refactoring.py) | Updated (Lesson 21) | Demonstrates the **refactoring of nested `if` statements** into the `if/elif` structure, highlighting the trade-off between **complexity** and **conditional exclusivity**.

| [`py_101/elif_order_dependence.py`](py_101/elif_order_dependence.py) | New (Lesson 22) | Demonstrates **order dependence** in `if/elif` ladders, showing how Python's **short-circuiting** critically affects which condition is evaluated as True. |

| [`py_101/for_loops_and_range.py`](py_101/for_loops_and_range.py) | New (Lesson 23) | Demonstrates all forms of the **`range()`** function (1, 2, and 3 arguments), including forward, reverse, and accumulating sums within **`for` loops**. |

| [`py_101/while_loop_basics.py`](py_101/while_loop_basics.py) | New (Lesson 24) | Demonstrates the structure of the **`while` loop**, focusing on the crucial need for a control (update/sentinel) variable to prevent **infinite loops**. |

### 2. Homework Assignments



*To be populated with larger, multi-concept solutions.*



### 3. Small Automation Tools



*Future projects focusing on efficiency and real-world problem-solving.*



### 4. Fun Experiments



*Future projects focused on creativity, visualization, and new libraries.*


## ü§ù Community & Technical Discussions

I believe in active participation and professional discourse. This section logs external discussions related to my learning process, workflow, and core technical concepts.

* **Reddit Post:** [Accelerating Py 101 with an Engineer's Workflow](https://www.reddit.com/r/maestro/comments/1otaoge/maestro_ai_academy_accelerating-my-python-base_py/)

  * **Focus:** AI-Assisted Documentation (Gemini), Portfolio Structure (GitHub/README), `is` vs. `==` Conceptual Clarity, Finding a Study Partner.


## üåé Vision



My ultimate goal is to leverage AI to help humanity build a better future.



**More coming soon!**
